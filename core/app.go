package core

import (
	"fmt"
	"os"
)

type App struct {
	Debug  bool
	index  *Index
	config *Config
}

func NewApp() *App {
	debug := false
	config := NewConfig()
	idx, err := NewIndex(config)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating database: %v\n", err)
		os.Exit(1)
	}

	return &App{
		Debug:  debug,
		index:  idx,
		config: config,
	}
}

func (a *App) Close() {
	if a.index != nil {
		a.index.Close()
	}
}

func HumanizeBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

func GetTrashPath() string {
	path := os.Getenv("HOME") + "/.Trash"

	// Check if the directory exists
	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Warning: Trash directory %s does not exist\n", path)
	}

	return path
}

func (a *App) ShowConfig() {
	fmt.Printf("Database file: %s\n", a.index.GetIndexPath())
	fmt.Printf("Minimum file size: %d bytes\n", a.config.GetMinFileSize())
	fmt.Printf("Binary compare byte size: %d bytes\n", a.config.BinaryCompareBytes)
	fmt.Printf("Database filename: %s\n", a.config.GetDBFilename())
	fmt.Printf("System trash directory: %s\n", GetTrashPath())
}

func (a *App) ShowFiles() {
	files := a.index.GetAllFiles()
	if len(files) == 0 {
		fmt.Println("No files in database")
		return
	}
	// show each file path
	for _, file := range files {
		fmt.Println(file.Path)
	}
	// show totals
	fmt.Printf("Files in database: %d total.\n", len(files))
}

func (a *App) ShowDupes() {
	files := a.index.GetDuplicateFiles()
	if len(files) == 0 {
		fmt.Println("No duplicate files in database")
		return
	}
	// show each file path
	for _, file := range files {
		fmt.Println(file.Path)
	}
	// show totals
	fmt.Printf("Duplicate files in database: %d total.\n", len(files))
}

func (a *App) ShowHashes() {
	files := a.index.GetAllHashedFiles()
	if len(files) == 0 {
		fmt.Println("No hashed files in database")
		return
	}
	// show each file path
	for _, file := range files {
		fmt.Println(file.Path)
	}
	// show totals
	fmt.Printf("Hashed files in database: %d total.\n", len(files))
}

func (a *App) Scan() {
	// No files in FileIndex skip
	files := a.index.GetAllFiles()
	if len(files) == 0 {
		fmt.Println("No files in database. Nothing to scan.")
		return
	}

	// Todo: Start a  system timer and measure scan duration

	scanner := NewScanner(a.index)              // Create scanner instance
	results, err := scanner.ScanForDuplicates() // Call method on scanner

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Print results
	if len(results) == 0 {
		fmt.Println("No duplicate files found!\n")
	} else {
		fmt.Print()
		fmt.Printf("Found %d group(s) of duplicate files:\n", len(results))

		totalDuplicateSize := int64(0)
		totalDuplicateFiles := 0

		for i, result := range results {
			fmt.Printf("\nGroup %d (Hash: %s):\n", i+1, result.HashSum)
			groupSize := int64(0)
			var firstFile *FileItem

			for j, guid := range result.FileGuids {
				file := a.index.GetFileByGuid(guid)
				if file != nil {
					if firstFile == nil {
						firstFile = file
					}
					fmt.Printf("  %s (%s)\n", file.Path, file.HumanizedSize)
					if j > 0 { // Count all duplicates except the first (original)
						totalDuplicateFiles++
						groupSize += file.Size
					}
				}
			}
			totalDuplicateSize += groupSize
		}

		// Summary
		fmt.Printf("\nSummary: %d duplicate files in %d groups, %s used space\n",
			totalDuplicateFiles, len(results), HumanizeBytes(totalDuplicateSize))
	}
}

func (a *App) Export() {
	files := a.index.GetDuplicateFiles()

	// No files in FileIndex skip
	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No duplicate files in database\n")
		os.Exit(1)
	}

	fmt.Printf("# DupeFiles Export - Found %d groups of duplicate files\n", len(files))
	fmt.Printf("# Generated by DupeFiles v0.1.0\n")
	fmt.Printf("# Format: [Group Number] [Hash] [File Count] [Total Size]\n")
	fmt.Println("#")

	totalDuplicateSize := int64(0)
	totalFiles := 0

	for i, file := range files {
		totalFiles++
		groupSize := file.Size // Größe des duplizierten Files
		totalDuplicateSize += groupSize

		fmt.Printf("[Group %d] %s %d %s\n", i+1, file.Hash, 1, HumanizeBytes(groupSize))
		fmt.Printf("- %s (%s)\n", file.Path, file.HumanizedSize)
		fmt.Println() // Empty line between groups
	}

	// Important: here the total size is larger than in Scan() because we include all files \
	// even the possible original file of a duplicate group.
	fmt.Printf("# Summary: %d possible duplicate files in %d groups, %s used space\n",
		totalFiles, len(files), HumanizeBytes(totalDuplicateSize))
}

func (a *App) PurgeIndex() {
	count, err := a.index.Purge()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Purged %d files from the database\n", count)
}

func (a *App) UpdateIndex() {
	count, err := a.index.Update()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Updated %d files in the database\n", count)
}

func (a *App) AddPath(path string, recursive bool, filter string) {
	if path == "" {
		fmt.Fprintf(os.Stderr, "Error: No path specified\n")
		os.Exit(1)
	}

	fileInfo, err := os.Stat(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// remember  current amount of indexed files
	currentCount := len(a.index.GetAllFiles())

	// add directory or file
	if fileInfo.IsDir() {
		err = a.index.AddDirectory(path, recursive, filter)
	} else {
		err = a.index.AddFile(path)
		if err == nil {
			fmt.Printf("Added: %s\n", path)
		}
	}

	// remember new amount of indexed files
	newCount := len(a.index.GetAllFiles())
	// display changed files
	fmt.Printf("Updated %d files\n", newCount-currentCount)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func (a *App) RemovePath(path string) {
	if path == "" {
		fmt.Fprintf(os.Stderr, "Error: No path specified\n")
	}
}

func (a *App) MoveDuplicates(path string) {
	if path == "" {
		fmt.Fprintf(os.Stderr, "Error: No path specified\n")
	}

	dirInfo, err := os.Stat(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	if !dirInfo.IsDir() {
		fmt.Fprintf(os.Stderr, "Error: %s is not a directory\n", path)
	}

	// move files to directory
	files := a.index.GetDuplicateFiles()
	for _, file := range files {
		err = os.Rename(file.Path, path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}
	}
	fmt.Printf("Moved %d duplicate files to %s\n", len(files), path)

	// Todo: Update database
	// Update path of file
	// Remove duplicate file?

}

func (a *App) MoveDuplicatesToTrash() {
	// Get OS specific path of trash directory
	trashpath := GetTrashPath()
	// Move duplicate files
	a.MoveDuplicates(trashpath)
}

// Delete from duplicate table
func (a *App) DatabaseForgetDuplicates() {
	a.index.ForgetDuplicates()
}

// Null all hashes in the database file table
func (a *App) DatabaseForgetHashes() {
	a.index.ForgetHashes()
}
