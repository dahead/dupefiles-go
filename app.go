package main

import (
	"fmt"
	"os"
)

type App struct {
	index  *Index
	config *Config
}

func NewApp() *App {
	config := NewConfig()
	idx, err := NewIndex(config)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating database: %v\n", err)
		os.Exit(1)
	}

	return &App{
		index:  idx,
		config: config,
	}
}

func (a *App) Close() {
	if a.index != nil {
		a.index.Close()
	}
}

func HumanizeBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

func (a *App) ShowConfig() {
	fmt.Printf("Database file: %s\n", a.index.GetIndexPath())
	fmt.Printf("Minimum file size: %d bytes\n", a.config.GetMinFileSize())
	fmt.Printf("Database filename: %s\n", a.config.GetDBFilename())
}

func (a *App) ShowFiles() {
	files := a.index.GetAllFiles()
	if len(files) == 0 {
		fmt.Println("No files in database")
		return
	}
	// show each file path
	for _, file := range files {
		fmt.Println(file.Path)
	}
	// show totals
	fmt.Printf("Files in database (%d total):\n", len(files))
}

func (a *App) ShowDuplicates() {
	files := a.index.GetDuplicateFiles()
	if len(files) == 0 {
		fmt.Println("No duplicate files in database")
		return
	}
	// show each file path
	for _, file := range files {
		fmt.Println(file.Path)
	}
	// show totals
	fmt.Printf("Duplicate files in database (%d total):\n", len(files))
}

func (a *App) Scan() {

	// No files in FileIndex skip
	files := a.index.GetAllFiles()
	if len(files) == 0 {
		fmt.Println("No files in database")
		return
	}

	scanner := NewScanner(a.index)              // Create scanner instance
	results, err := scanner.ScanForDuplicates() // Call method on scanner

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Print results
	if len(results) == 0 {
		fmt.Println("No duplicate files found")
	} else {
		fmt.Printf("Found %d groups of duplicate files:\n", len(results))
		for i, result := range results {
			fmt.Printf("\nGroup %d (Hash: %s):\n", i+1, result.HashSum)
			for _, guid := range result.FileGuids {
				file := a.index.GetFileByGuid(guid)
				if file != nil {
					fmt.Printf("  %s (%s)\n", file.Path, file.HumanizedSize)
				}
			}
		}
	}
}

func (a *App) Export() {
	// Todo: Instead of getting all files, just get duplicates
	files := a.index.GetDuplicateFiles()

	// No files in FileIndex skip
	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No files in database\n")
		os.Exit(1)
	}

	scanner := NewScanner(a.index)              // Create scanner instance
	results, err := scanner.ScanForDuplicates() // Call method on scanner

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Export results to STDOUT in a structured format
	if len(results) == 0 {
		fmt.Println("# No duplicate files found")
		return
	}

	fmt.Printf("# DupeFiles Export - Found %d groups of duplicate files\n", len(results))
	fmt.Printf("# Generated by DupeFiles v0.1.0\n")
	fmt.Printf("# Format: [Group Number] [Hash] [File Count] [Total Size]\n")
	fmt.Println("#")

	totalDuplicateSize := int64(0)
	totalFiles := 0

	for i, result := range results {
		groupSize := int64(0)
		var firstFile *FileItem

		// Calculate group size and get first file for reference
		for _, guid := range result.FileGuids {
			file := a.index.GetFileByGuid(guid)
			if file != nil {
				if firstFile == nil {
					firstFile = file
				}
				totalFiles++
			}
		}

		if firstFile != nil {
			groupSize = firstFile.Size * int64(len(result.FileGuids)-1) // Size of duplicates (excluding original)
			totalDuplicateSize += groupSize
		}

		fmt.Printf("[Group %d] %s %d %s\n", i+1, result.HashSum, len(result.FileGuids), HumanizeBytes(groupSize))

		for j, guid := range result.FileGuids {
			file := a.index.GetFileByGuid(guid)
			if file != nil {
				marker := "  "
				if j == 0 {
					marker = "* " // Mark first file as potential "original"
				} else {
					marker = "- " // Mark others as duplicates
				}
				fmt.Printf("%s%s (%s)\n", marker, file.Path, file.HumanizedSize)
			}
		}
		fmt.Println() // Empty line between groups
	}

	fmt.Printf("# Summary: %d duplicate files in %d groups, %s wasted\n",
		totalFiles-len(results), len(results), HumanizeBytes(totalDuplicateSize))
}

func (a *App) Purge() {
	count, err := a.index.Purge()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Purged %d non-existent files in the database\n", count)
}

func (a *App) Update() {
	count, err := a.index.Update()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Updated %d nonfiles in the database\n", count)
}

func (a *App) AddPath(path string, recursive bool, filter string) {
	if path == "" {
		fmt.Fprintf(os.Stderr, "Error: No path specified\n")
		os.Exit(1)
	}

	fileInfo, err := os.Stat(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// remember  current amount of indexed files
	currentCount := len(a.index.GetAllFiles())

	// add directory or file
	if fileInfo.IsDir() {
		err = a.index.AddDirectory(path, recursive, filter)
	} else {
		err = a.index.AddFile(path)
		if err == nil {
			fmt.Printf("Added: %s\n", path)
		}
	}

	// remember new amount of indexed files
	newCount := len(a.index.GetAllFiles())
	// display changed files
	fmt.Printf("Added/Updated %d files\n", newCount-currentCount)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
